## 动态规划

### 1.引例

#### 斐波那契数列

[1,1,2,3,5,8,....]

计算任意索引位置i的斐波那契数？

1）使用**递归**的方法

fib(n) = fib(n-1) + fib(n-2)
出口：i=1和i=2

``` java
public int fibonacii(int i){
    if(i==1 || i == 2)
        return 1;
    return fibonacii(i-1)+fibonacii(i-2);
}
```

特点：重叠子问题，时间复杂度到达2的n次方。因为两个分支会重复进行计算以前递归计算的函数。

比如fib(7)会计算fib(6)和fib(5)，而fib(6)又会计算一次fib(5)，

2）改进：使用**数组**代替——记忆化搜索

代码：

``` java
public int fibonacii(int i){
    int[] arr = new int[i];
    arr[0] = arr[1] = 0;
    for(int j = 2;j<i;j++){
        arr[j] = arr[j-1] + arr[j-2];
    }
    return arr[i-1];
}
```

第二种方式使用了一个数组缓存，可以大大提高效率。时间复杂度O(n)。空间换时间！

### 01背包问题

问题：总共有n个物品，每个物品的体积为Vi，价值为Wi，要使得在背包总空间为K的条件下，背包所能容纳的最大价值？

**dp[i] = max(w[i] + dp[k-v[i]],dp[i-1])**



### 01背包拓展——互斥任务

![1554555018635](D:\GitPro\Note\算法\动态规划.assets\1554555018635.png)

有一些工作任务，分别标号为1，2，3，...，每个任务有对应的开始与结束时间，必须要在指定的时间内完成这个任务，在同一时间只能进行一个任务。此外，每个任务完成后能获得相应的回报，例如完成任务1将获得5回报，任务1需要从1时刻开始，到4时刻结束，若选择了这个任务，在这段时间内不能做其他任务。问：从所有的任务中选择出要完成的任务，使得获得的收益最大？

1.每个任务有选与不选两种状态？0或者1
2.从最后一个任务开始，依次向前。若选择了最后一个任务8，则下一个任务只能是从5开始，若不选，则从7开始。

![1554555741137](D:\GitPro\Note\算法\动态规划.assets\1554555741137.png)

归纳为：

![1554555943201](D:\GitPro\Note\算法\动态规划.assets\1554555943201.png)



#### 1).prev是一个数组，记录若选择了任务i，则可以选择的上一个任务为：prev[i]。

| i    | prev[i] |
| :--- | :------ |
| 0    | 0       |
| 1    | 0       |
| 2    | 0       |
| 3    | 1       |
| 4    | 0       |
| 5    | 2       |
| 6    | 3       |
| 7    | 5       |

需要根据数组计算出prev。

#### 2).使用dp的方式计算。

``` java
/**
 * @param task_value 长度为任务数加一，并且task_value[0]=0;task_value[i]对应任务i的价值。
 * @param prev
 * @return
 */
static int dp_opt(int[] task_value,int[] prev){
    int[] dp = new int[task_value.length];
    dp[0] = task_value[0];
    dp[1] = task_value[1];
    for(int j = 2;j  < task_value.length; j++){
        dp[j] = Math.max(task_value[j]+dp[prev[j]],dp[j-1]);
    }
    return dp[task_value.length-1];
}
```

如何知道选择了哪些任务？

#### 3）输出选择了的任务

【待解决】



### 选择不相邻的数字